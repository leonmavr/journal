\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}


%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% PREAMBLE
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Important styling notes
%%
% For now, to include img.jpg in img/path/to/img.jpg, just use:
% path/to/img.jpg - for details see style.tex
\input{style.tex}




\begin{document}
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% GLOBAL STYLES (DOCUMENT SCOPE)
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% caption: Figure 1 -> <bold> Fig. 1 </bold>
\captionsetup[figure]{labelfont={bf},labelformat={default},labelsep=period,name={Fig.}}


%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% TITLE PAGE
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\input{title.tex}
%\maketitle



%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% MAIN DOCUMENT
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\tableofcontents
\newpage



%------------------------------ New section ------------------------------%
\section{Line rasterisation -- Bresenham's algorithm}


\subsection{Introduction}
Bresenham's line drawing algorithm was proposed in 1962. It takes as input two points and draws a line between in a discrete 2D grid. It decides either to draw or not to draw a pixel by traversing them in a certain way.


% https://cse.iitkgp.ac.in/~pb/pb-graphics-2018.pdf
% https://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html
% http://www.csc.villanova.edu/~mdamian/Past/csc8470sp15/notes/Rasterization.pdf
% https://blog.mbedded.ninja/programming/algorithms-and-data-structures/bresenhams-line-algorithm/
% https://www.youtube.com/watch?v=y_SPO_b-WXk
\subsection{Bresenham's assumptions}

\begin{enumerate}
	\item All pixels are sampled in a discrete 2D lattice.
	\item The algorithm does not draw any colours -- it simple decides whether to draw a pixel or not.
	\item The line generated does not contain any holes. All line pixels must be 8-connected and for each column ($x$) there must be only one corresponding row ($y$). 
\end{enumerate}
To understand its advantages, we'll try to derive the algorithm.


\subsection{Deriving the algorithm}
\subsubsection{First attempt; a naive implementation}

Given two points $(x_1,y_1), \; (x_2,y_2)$, a naive first implementation is to iterate over all $x$'s and find their $y$'s as follows:
\begin{equation}
	y = \textup{round}(m\cdot x + b), \quad m = \frac{y_2 - y_1}{x_2 - x_1} 
\end{equation}
Translated to C:
\begin{verbatim}
#include <math.h>

/* Draw a line in a naive way assuming x1 < x2 */
void gfx_naive_line(int x1, int y1, int x2, int y2)
{
    // y = mx + b
    float m = (y2 - y1)/(x2 - x1);
    float b = y1 - m*x1; 
    int x;
    int y;
    for (x = x1; x < x2; x++)
    {
        y = round(m*x + b);
        gfx_point(x,y);
    }
}
\end{verbatim}
The drawback of this approach is that for each pixel it uses 2 floating point operations, plus rounding;
\begin{itemize}
	\item Multiplication \texttt{m*x}
	\item Addition of \texttt{m*c} with \texttt{b}
\end{itemize}
The cost of these operations adds up when 100s of pixels are drawn every time. Floating point operations are relatively expensive for CPUs and replacing them with integer arithmetic is a significant optimisation. Bresenham's algorithm fully relies on integer operations.


\subsubsection{Bresenham's line drawing algorithm idea}
For now, we'll only be implementing the algorithm in the first octant ($0\degree$ to $45\degree$ with $x$ axis), i.e. assume that for the slope of the line $0 \leq m \leq 1$. We'll later exploit the circular symmetry to derive the remaining 7 octants given the first. To reiterate, the main constraint imposed is
\begin{equation}
	0 \leq m \leq 1,\quad m = \frac{y_2-y_1}{x_2-x_1} 
	\label{eq:slope_leq_1}
\end{equation}
, i.e. $x_2 - x_1 \geq y_2 - y_1$.
\begin{figure}[H]
	\centering
	\includegraphics[height=5.5cm]{img/octants.png}
	\caption{The 8 octants and their slopes \cite{mallinus}.}
	\label{fig:octants}
\end{figure}

Let's say we have plotted a pixel $(x,y)$ of the rasterised line. Because of the constraint in \eqref{eq:slope_leq_1}, the next pixel can be either East ($x+1,y$) or North-East ($x+1,y+1$). When the line is drawn in 2D, for each step from $x$ to $x+1$, we have to find whether $y$ or $y+1$ is closest to the $y$ (floating) of the line. To do that, we increment $y$ by the slope $m$ (def'n of slope) and have to determine whether $y+m$ is above or below the midway $y+0.5$  between $y, \ y+1$ (Fig. \ref{fig:grid_line_1st_octant}).

\begin{multicols}{2}
	\begin{figure}[H]
		\centering
		\includegraphics[height=4cm]{img/next_pixel_n_ne.png}
		\caption{At every update of pixel $(x,y)$, we choose between the E and NE neighbour \cite{mdamian}.}
		\label{fig:}
	\end{figure}
\columnbreak
	\begin{figure}[H]
	\centering
	\input{tikz/grid2.tex}
	\caption{The nodes represent pixel centres and the segments the midway $y$ between neighbouring pixels. Nodes in magenta represent where the line will be drawn in the 2D discrete space.}
	\label{fig:grid_line_1st_octant}
\end{figure}


\end{multicols}

\subsubsection{Bresenham's line drawing at 1st octant; the derivation}

Because we plot the original line in a discrete grid given a resolution, it will almost never cross a discrete point. Therefore it will always be at some error $\epsilon$ above or below the nearest discrete $y$. For the error \cite{mallinus},
\begin{equation}
	-0.5 \leq \epsilon <0.5
\end{equation}
The $y_{actual}$ ordinate of the line is then given by $y_{actual} = y+\epsilon$. In moving from $x$ to $x+1$ we increase the value of the true (mathematical) $y$-ordinate by an amount equal to the slope $m$ (Fig. \ref{fig:error_diagram}).
\begin{figure}[H]
	\centering
	\includegraphics[height=4.5cm]{img/error_diagram.png}
	\caption{The error at each pixel during the update \cite{mallinus}.}
	\label{fig:error_diagram}
\end{figure}
From the plot in Fig. \ref{fig:error_diagram}, it is clear after the transition $x\rightarrow x+1$, if 
\begin{gather*}
	y + \epsilon + m < y+  0.5 \Rightarrow\\
	\epsilon + m < 0.5
\end{gather*}
, then we move East ($x+1,y$) to represent the line. Else we move North-East ($x+1,y+1$). We make this decision to minimise the total error between what gets drawn on the display and the actual values.

However, after $x\rightarrow x+1$ the error gets updated too from $\epsilon$ to $\epsilon_{new}$. We know that the error the distance of the mathematical line to the nearest $y$-ordinate of the grid, i.e. either $y$ or $y+1$. In case $(x+1,y)$, the new error is given by \cite{mallinus} (Fig. \ref{fig:error_diagram})
\begin{equation}
	\epsilon_{new} \leftarrow (y+\epsilon + m) - y  = \epsilon + m
\end{equation}
Else, if ($x+1,y+1$) was chosen
\begin{equation}
	\epsilon_{new} \leftarrow (y+\epsilon + m) - (y+1) = \epsilon + m -1	
\end{equation}
Therefore a first implementation of the line drawing algorithm so far is below. Note that it still uses floating point which must be eliminated. Note also that for the algorithm to be consistent with the idea developed thus far, it is assumed that $(x_1,y_1)$ is closer to the origin than $(x_2,y_2)$.
\begin{algorithm}[H]
\caption{Line drawing with FP operations.}
\label{alg:line_drawing_fp}
\begin{algorithmic}[1]
\Procedure{Line-Drawing-FP} {$x_1,\; y_1,\; x_2,\; y_2$} 
	\State $m \leftarrow \frac{y_2-y_1}{x_2-x_1} $
	\State $\epsilon \leftarrow 0, \; y\leftarrow y_1$ \Comment{$\epsilon, \; y$ are all we keep track of.}
\For{$x=x_1,\ldots,x_2$} 
	\State DrawPixel($x,\; y$)
	\If{$\epsilon + m < 0.5$}
		\State $\epsilon \leftarrow \epsilon + m$ \Comment{Move E; don't change $y$}
	\Else
		\State $\epsilon \leftarrow \epsilon + m - 1$ \Comment{Move NE}
		\State $y\leftarrow y + 1$
	\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
\marginnote{Bresenham relies on integer operations.}To optimise the algorithm, we must convert the following to integer operations
\begin{gather*}
\epsilon + m < 0.5 \tag{1}	\\
	\epsilon \leftarrow \epsilon + m \tag{2}\\
	\epsilon \leftarrow \epsilon + m - 1 \tag{3}
\end{gather*}
Plugging in $m=\Delta x/\Delta y = (y_2-y_1)/(x_2-x_1)$, Eq. (1) becomes
\[	
	2\underbrace{\epsilon\Delta x}_{\epsilon'}  + 2\Delta y < \Delta x \tag{1'}
\]
Eq. (2) and (3) become respectively
\begin{gather*}
	\underbrace{\epsilon\Delta x}_{\epsilon'} \leftarrow \underbrace{\epsilon \Delta x}_{\epsilon'} + \Delta y \tag{2'}\\
	\underbrace{\epsilon\Delta x}_{\epsilon'} \leftarrow \underbrace{\epsilon \Delta x}_{\epsilon'} + \Delta y - \Delta x \tag{3'}\\
\end{gather*}
\marginnote{Algo stated assuming $0\leq m \leq 1$ and $x_1<x_2$.}.The quantity $\epsilon\Delta x$ appears in all Eq. (1'), (2'), (3') therefore we let $\epsilon' := \epsilon \Delta x$. The algorithm we have arrived in is \textit{Bresenham's for the 1st octant}. It is written in integer arithmetic as follows:
\begin{algorithm}[H]
\caption{Bresenham's line drawing -- 1st octant.}
\label{alg:bres_1st_oct}
\begin{algorithmic}[1]
\Procedure{Bresenham-1st-Octant} {$x_1,\; y_1,\; x_2,\; y_2$} 
	\State $\Delta x \leftarrow x_2 - x_1$
	\State $\Delta y \leftarrow y_2 - y_1$
	\State $\epsilon' \leftarrow 0, \; y\leftarrow y_1$ \Comment{$\epsilon', \; y$ are all we keep track of.}
	\If {$0 \leq \frac{\Delta y}{\Delta x} < 1 $}
\For{$x=x_1,\ldots,x_2$} 
	\State DrawPixel($x,\; y$)
	\If{$2(\epsilon'  + \Delta y) < \Delta x$}
		\State $\epsilon' \leftarrow \epsilon' + \Delta y$ \Comment{Move E; don't change $y$}
	\Else
		\State $\epsilon' \leftarrow \epsilon' + \Delta y - \Delta x$ \Comment{Move NE}
		\State $y\leftarrow y + 1$
	\EndIf
\EndFor
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
This version is particularly efficient not only due to integer arithmetic but as multiplication by 2 can be implemented as left bit shifting. We can of course move the update $\epsilon' \leftarrow \epsilon'+\Delta y$ before the if-else block to end up with only one if for slightly more conciseness. 


\subsubsection{Bresenham's line drawing algorithm in octant 2}

We now address the case of drawing a line with slope $1 \leq m < \infty$, i.e. one that spans at the 2nd octant (Fig. \ref{fig:octants}). Note that a line $(l1): \; y=mx+b$ with slope $0 \leq m < 1$ in the first octant is symmetric w.r.t to $y=x$ to the line $(l2): \; x=my+b \Leftrightarrow y = \frac{x}{m} - \frac{b}{m}$ (e.g. Fig. \ref{fig:symmetric_lines_octants_1_2}). If $(x_0,y_0)\in(l1)$ then $(y_0,x_0)\in (l2)$. Therefore to rasterise $(l2)$ we can apply Alg. \ref{alg:bres_1st_oct} on it modified by swapping $x$ with $y$ and $\Delta x$ with $\Delta y$. Don't forget the ordinate condition for the 2nd octant, which is $y_1<y_2$.
\begin{figure}[H]
	\centering
	\input{tikz/lines_1st_2nd_octant.tex}
	\caption{Two lines in the first two octants symmetric about line $y=x$.}
	\label{fig:symmetric_lines_octants_1_2}
\end{figure}
\begin{algorithm}[H]
\caption{Bresenham's line drawing -- 2nd octant.}
\label{alg:bres_2nd_oct}
\begin{algorithmic}[1]
\Procedure{Bresenham-2nd-Octant} {$x_1,\; y_1,\; x_2,\; y_2$} 
	\State $\Delta x \leftarrow x_2 - x_1$
	\State $\Delta y \leftarrow y_2 - y_1$
	\State $\epsilon' \leftarrow 0, \; x\leftarrow x_1$ \Comment{$\epsilon', \; y$ are all we keep track of.}
	\If {$1\leq \frac{\Delta y}{\Delta x} $ and $y_1<y_2$}
		\For{$y=y_1,\ldots,y_2$} 
			\State DrawPixel($x,\; y$)
			\If{$2(\epsilon'  + \Delta x) < \Delta y$}
				\State $\epsilon' \leftarrow \epsilon' + \Delta x$ 
			\Else
				\State $\epsilon' \leftarrow \epsilon' + \Delta x - \Delta y$ 
				\State $x\leftarrow x + 1$
			\EndIf
		\EndFor
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
Octants 1 and 2 (quadrant 1) have been addressed. To complete the algorithm in the remaining 6 octants, observe that quadrant 2 (octants 3,4) is symmetric with quadrant 1 w.r.t the $y$ axis. Quadrant 3 (octants 5, 6) is symmetric with 1 w.r.t $x$ and $y$ axes, and quadrant 4 is symmetric with 1 w.r.t the $x$ axis.


\subsubsection{Bresenham's line drawing algorithm in octants 3 and 4}

Octants 3 and 4 are symmetric w.r.t the $y$ axis to octants 2 and 1 respectively. Therefore to derive their line drawing we start with Alg. \ref{alg:bres_2nd_oct} and \ref{alg:bres_1st_oct} respectively and substitute $(-x,y) \leftarrow (x,y)$, $\Delta x \leftarrow -\Delta x$. Therefore the line drawing for those octants is formulated as follows, renaming the error $\epsilon'$ to $\epsilon$ for simplicity.
\begin{algorithm}[H]
\caption{Bresenham's line drawing -- 2nd quadrant.}
\label{alg:bres_2nd_qd}
\begin{algorithmic}[1]
\Procedure{Bresenham-2nd-Quadrant} {$x_1,\; y_1,\; x_2,\; y_2$} 
	\State $\Delta x \leftarrow x_2 - x_1$
	\State $\Delta y \leftarrow y_2 - y_1$
	\State $\epsilon \leftarrow 0, \; y\leftarrow y_1$ 
	\If {$\frac{\Delta y}{\Delta x} < -1$ and $y_1 < y_2$} \Comment{This is the 3rd octant (2nd octant mirror w.r.t $y$ axis)}
		\For{$y=y_1,\ldots,y_2$} 
			\State DrawPixel($x,\; y$)
			\If{$2(\epsilon  - \Delta x) < \Delta y$}
				\State $\epsilon \leftarrow \epsilon - \Delta x$ 
			\Else
				\State $\epsilon \leftarrow \epsilon - \Delta x - \Delta y$ 
				\State $x\leftarrow x - 1$
			\EndIf
		\EndFor
	\ElsIf {$0 \leq \frac{\Delta y}{\Delta x} < -1 $ and $x_2 < x_1$} \Comment{4th octant (1st octant mirrored w.r.t $y$ axis)}
			
		\For{$x=x_1,\ldots,x_2$} 
			\State DrawPixel($x,\; y$)
			\If{$2(\epsilon  + \Delta y) < -\Delta x$}
				\State $\epsilon \leftarrow \epsilon + \Delta y$
			\Else
				\State $\epsilon \leftarrow \epsilon + \Delta y + \Delta x$ 
				\State $y\leftarrow y + 1$
			\EndIf
	    \EndFor	
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
In the same way, given the algorithm for the first two octants, using the transform $(x,y) \leftarrow (-x,-y), \; \Delta x \leftarrow -\Delta x$, $\Delta y \leftarrow -\Delta y$ we can derive octants 5 and 6. Finally, using $(x,y) \leftarrow (x,-y), \; \Delta y \leftarrow -\Delta y$ we can derive octants 7 and 8. The $x$'s, $y$'s, $\Delta x$'s and $\Delta y$'s for each octant given the first are summarised in Fig. \ref{fig:all_octants_x_y}.

\begin{figure}[H]
	\centering
	\input{tikz/bres_circle_symmetry.tex}
	\caption{The Bresenham signs for the full circle given the 1st octant.}
	\label{fig:all_octants_x_y}
\end{figure}


\subsection{Bresenham's line drawing generalisation and implementation}

The first step of the algorithm generalisation is to determine the octant of the line, which is done with the aid of the conditions in Fig. \ref{fig:octants}. Next, we start from the algorithm for quadrants 1 and 2 and transform the $x$'s, $y$'s, $\Delta x$'s and $\Delta y$'s given the symmetry . The pseudocode for the full algorithm is listed in \ref{app:bresenham_full_p}.

To implement Bresenham and draw pixels in C, Prof D. Thain's ``gfx'' graphics library \cite{thain} was used. Method \texttt{gfx\_line\_bres} was added to implement the algorithm. To test it, each line was plotted against the library's \texttt{gfx\_line} method and the lines overlapped for all 8 octants. The code for the full algorithm in C is found in \ref{app:bresenham_full_src}.

Finally, note that the algorithm runs in linear ($\mathcal{O}(n)$) time.


\subsection{Summary -- pros and cons}
Bresenham's algorithm may be easy to implement and fast, but has a certain disadvantage. However it is still used by graphics cards and software libraries \cite{bhowmick} thanks to its simplicity.

Pros:
\begin{itemize}
	\item Simple to implement, can be efficiently implemented practically on any hardware!
	\item Fast -- i.e. linear time.
\end{itemize}
Cons:
\begin{itemize}
	\item Does not account for aliasing.
\end{itemize}




\clearpage
\section{B\'ezier and De Chasteljau curves from a programmer's perspective}%
\label{sec:bezier_and_de_chasteljau_curves_from_a_programmer_s_perspective}


\subsection{Applications}
B\'ezier (1910--1999) and De Chasteljau (1930--) were/are two mathematicians who established an intuitive and efficient way of drawing smooth and constrained curves given only a few control points. They focused on cubic curves as cubic curves are not only smoothly joined but also have no ``wiggles'''. Several decades ago, this property made them applicable to car design, as B\'ezier and De Chasteljau used to independently from each other work for Renault and Citr\"oen respectively. Currently, however, their applications have been extended not only to software (fonts, scalable graphics, graphical design applications such as Inkscape etc.), but also to ship, aircraft design, etc.
\begin{figure}[H]
    \centering
    \includegraphics[height=4cm]{img/bezier/s_letter_control_points.png}
    \caption{To render the S character at any size, only a few control points are needed (dots) instead of the entire curve.}%
\end{figure}
We will denote B\'ezier-De Chasteljau curves as BCD curves. BDC curves are parametric curves (instead of $x$ and $y$, they are defined given some scalar parameter $t$) and are based on a certain type of polynomials called Bernstein polynomials, which have some neat properties.
\begin{figure}[H]
    % ref CSU CS410 (c) Bruce Draper & J. Ross Beveridge
    \centering
    \includegraphics[height=3.5cm]{img/bezier/pen_paper.png}
    \caption{When we draw a curve with a pen, instead of describing the position as $(x,y)$, we can describe it w.r.t $t$: $t\mapsto x(t), y(t)$.}%
    \label{fig:name}
\end{figure}



\subsection{Bernstein polynomials}
\subsubsection{The Bernstein polynomial subspace}
As already known, 3rd degree polynomials are defined as:
\begin{equation*}
    P(t) = 1\cdot a_0 + a_1t + a_2t^2 + a_3t^3
\end{equation*}
The functions $\{1,t,t^2,t^3\}$ form a monomial basis (a.k.a. \emphasis{Hermite basis}). Therefore the dimension of the space they are a basis of is 4 (since we have 4 basis vectors). Bernstein  3rd degree polynomials are defined as follows:
\begin{equation}
    P(t) = (1-t)^3b_0 + 3(1-t)^2tb_1 + 3(1-t)t^2b_2 + t^3b_3
\end{equation}
Just for reference, the general definition of Bernstein polynomials is provided.
\begin{definition}[Bernstein polynomial]
The Bernstein polynomial basis functions of degree $n$ are defined as:
% ref Computer Graphics CS 543 Lecture 12 (Part 1) Curves Prof Emmanuel Agu
\begin{equation}
    B_{in}(t) = {n \choose i}(1-t)^{n-i}t^i
    \label{eq:bernstein_coeffs_general}
\end{equation}
, where $i$ is the index of basis function.
\end{definition}
% ref Computer Graphics CS 543 Lecture 12 (Part 1) Curves Prof Emmanuel Agu
For instance, $B_{03}={3 \choose 0}(1-t)^{3-0}t^0 = (1-t)^3$, $B_{13}={3 \choose 1}(1-t)^{3-1}t^1 = 3(1-t)^2t$. Without loss of generality, we will see later from De Chasteljau algorithm that it suffices to restrict $t\in(0,1)$. Therefore the basis functions of 3rd degree Bernstein polynomials are $\{(1-t)^3,3(1-t)^2t,3(1-t)t^3,t^3\}$. They are a basis because they are linearly independent. Indeed, if
\[
    c_0(1-t)^3 + c_13(1-t)^2t + c_23(1-t)t^2 + c_3t^3 = 0 
\]
then
\[
    c_0 \left(\frac{1-t}{t}\right)^3 + 3 c_1 \left(\frac{1-t}{t}\right)^2 + 3 c_2 \left(\frac{1-t}{t}\right) + c_3 = 0
\]
Because $\frac{1-t}{t} > 0 \quad \forall \; t \in (0,1)$, we conclude that $c_0=c_1=c_2=c_3 = 0$.



\subsubsection{Change of basis from Hermite to Bernstein}
As a reminder, a cubic Hermite polynomial is defined as:
\[
    P(t) = a_0 + ta_1 + t^2a_2 + t^3a_3
\]
Therefore it is spanned by the ``monomial'' basis $\{1,t,t^2,t^3\}$.
A question that comes naturally at this point is how the Bernstein is transformed to a Bernstein one, which is $\{(1-t)^3, 3(1-t)^3t, 3(1-t)t^2, t^3\}$, or more generally; how a Hermite polynomial is transformed into a Bernstein one, which is:
\begin{align*}
    P(t) &= b_0(1-t)^3 + 3b_1(1-t)^2t + 3b_2(1-t)t^2 + b_3t^3 \\
    &= b_0(1-3t+3t^2-t^3) + b_1(3t-6t + 3t^3) + b_2(3t^2 - 3t^3) + b_3t^3 \\
    &=  \begin{bmatrix}1-3t+3t^2-t^3 & 3t-6t + 3t^3 & 3t^2 - 3t^3 & t^3\end{bmatrix}
        \underbrace{
            \begin{bmatrix}
                b_0 \\ b_1 \\ b_2 \\ b_3 
            \end{bmatrix}
        }_{\bB}
    \tag{1}
\end{align*}
Having expanded the Bernstein basis vectors, it's easy to map from Hermite to Bernstein with a matrix multiplication:
\[
   \begin{bmatrix}1-3t+3t^2-t^3 \\ 3t-6t + 3t^3 \\ 3t^2 - 3t^3 \\ t^3\end{bmatrix}\t = 
        \underbrace{
            \begin{bmatrix}
                1 & -3 & 3 & -1 \\
                0 & 3 & -6 & 3 \\
                0 & 0 & 3 & -3 \\ 
                0 & 0 & 0 & 1
            \end{bmatrix}
        }_{\bC}
        \underbrace{
            \begin{bmatrix}
                1 & t & t^2 & t^3 
            \end{bmatrix}
        }_{\textbf{H}}
        \tag{2}
\]
From Eq. (1), (2), we obtain that $P(t) = \textbf{H}\t\bC\t\bB$.
\begin{corollary}[change of basis from Hermite to Bernstein]
    The cubic Bernstein polynomial $P(t) = b_0(1-t)^3 + 3b_1(1-t)^2t + 3b_2(1-t)t^2 + b_3t^3$ can be written w.r.t. the standard monomial basis $\{1,t,t^2t^3\}$ as follows:
\begin{equation}
    P(t) =
    \begin{bmatrix}
        1 \\ t \\ t^2 \\ t^3 
    \end{bmatrix}\t
    \begin{bmatrix}
        1 & -3 & 3 -1 \\
        0 & 3 & -6 & 3 \\
        0 & 0 & 3 & -3 \\ 
        0 & 0 & 0 & 1
    \end{bmatrix}\t
   \begin{bmatrix}
        b_0 \\ b_1 \\ b_2 \\ b_3 
    \end{bmatrix}
\end{equation}
\end{corollary}


\subsubsection{Bernstein polynomials as blending functions}
The Bernstein polynomials (not just the cubic, but any degree) can also be viewed as a weighted average of their coefficients. Why a weighted average? Because the basis functions  sum to $1$.
\begin{corollary}[Bernstein basis functions sum to 1]
    The basis functions $\{B_{03}, B_{13}, B_{23}, B_{33}\} = \{(1-t)^3, 3(1-t)^3t, 3(1-t)t^2, t^3\}$ of the cubic Bernstein polynomial $P(t)=b_0(1-t)^3 + b_13(1-t)^2t + b_23(1-t)t^2 + b_3t^3$ sum to 1\footnote{This holds for any degree $n$, however we are only interested in the cubic case.}     
\end{corollary}
\begin{proof}
    \begin{align*}
        1 &= ((1-t)+t)^3 \\
         &= (1-t)^3 + 3(1-t)^3t + 3(1-t)t^2 + t^3
    \end{align*} 
\end{proof}
Hence it is said that $B_{i3}(t), \ i=0,1,2,3$ ``blend together'' the polynomial coefficients $b_i, \ i = 0,1,2,3$. Apart from the fact that they sum to 1, the basis functions $B_{i3}(t)$ are strictly positive for $t\in(0,1)$.
\begin{figure}[H]
    \centering
    \includegraphics[height=4.5cm]{img/bezier/bernstein_coeff_cubic.png}
    \caption{The 4 basis functions of the cubic Bernstein polynomial.}%
\end{figure}





\subsection{The B\'ezier curve}
\subsubsection{Definition}
Since Bernstein polynomials have been introduced, it is time to define the cubic B\'ezier curve $\fancyC(t)$:
\begin{equation}
    \fancyC(t) = (1-t)^3\bb_0 + 3(1-t)^2t\bb_1 + 3(1-t)t^3\bb_2 + t^3\bb_3, \quad t\in[0,1]
    \label{eq:bezier_curve}
\end{equation}
$\bb_i = (x_i, y_i)$ in this case are called control points because they control the shape of $\fancyC(t)$ as we will see soon. \eqref{eq:bezier_curve} can be also expanded in each dimension as:
\begin{align*}
    x(t) = (1-t)^3x_0 + 3(1-t)^2tx_1 + 3(1-t)t^3x_2 + t^3x_3\\
    y(t) = (1-t)^3y_0 + 3(1-t)^2ty_1 + 3(1-t)t^3y_2 + t^3y_3
\end{align*}



\subsubsection{Why are $\bb_i$ control points?}
Plugging in \eqref{eq:bezier_curve} $t=0$ and $t=1$ respectively:
\begin{align*}
    \fancyC(0) &= \bb_0\ ,\\
    \fancyC(1) &= \bb_3
\end{align*}
Therefore $\bb_0 = \fancyC(0)$ and $\bb_3 = \fancyC(1)$ control the beginning and end of the curve. If we derive $\fancyC(t)$, we furthermore compute:
\[
    \fancyC\prime(t) = 3(\bb_1-\bb_0)(1-t)^2 + 6(\bb_2-\bb_1)(1-t)t + 3(\bb_3-\bb_2)t^2
\]
Plugging in the derivative $t=0$ and then $t=1$:
\begin{align*}
    \fancyC\prime(0) &= 3(\bb_1-\bb_0)\ ,\\
    \fancyC\prime(1) &= 3(\bb_3-\bb_2)
\end{align*}
Therefore the tangent of $\fancyC(t)$ at the beginning ($t=0$) points from $\bb_0$ to $\bb_1$ and the tangent at the end points from $\bb_2$ to $\bb_3$. This is how $\bb_0, \bb_1, \bb_2, \bb_3$ control the curve. In general, a B\'ezier curve of degree $n$ is controlled by $n+1$ control points.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/bezier/tangents_control_points.png}
    \caption{How the control points affect the shape of the B\'ezier curve.}%
\end{figure}
It can also be proven that the tangent property holds for B\'ezier curves of any degree.


\subsubsection{Convex hull property}

The convex hull property states that the B\'ezier curve is always contained in the polygon formed by the 4 control points. Before it's proven, some definitions needs to be made.
\begin{definition}[convex set]
% (ref 10-725: Optimization Fall 2012 Lecture 3: September 4 Lecturer: Geoff Gordon Scribes: Adona Iosif, Xiaowen Ding, Yue Yu) 
    A set $C \subset \setR^n$ is convex iff for any two points $\bx_1,\bx_2$ in $C$, the line segment joining them \footnote{see parametric straight line equation in \ref{app:param_straight_line}} also lies in $C$, i.e. 
\begin{equation}
\theta\bx_1 + (1-\theta)\bx_2 \in C \quad \forall \theta \in [0,1], \quad \forall \bx_1, \bx_2 \in C
\end{equation}
\end{definition}
\begin{figure}[H]
    \centering
    \includegraphics[height=3.8cm]{img/bezier/convex_non_convex.png}
    \caption{Example of a convex (left) and a non convex set (right).}%
\end{figure}

\begin{definition}[convex hull]
Given a set of $n$ points $\{\bp_1,\ldots,\bp_n\}$, the \emphasis{convex hull} of them is defined as:
\begin{equation}
CH(p_1,\ldots,p_n) = \Big\{\bp_1p_1 + \ldots + \bp_np_n \; | \; p_1,\ldots,p_n\in[0,1] \; \land \; \sum_{i=1}^n p_i = 1\Big\} 
\end{equation}
\end{definition}
% ref chapter 9 bezier curves
The convex hull is a set of points is alternatively defined as the smallest convex set containing all points. Visually speaking the convex hull can be pictured by stretching an elastic band so that it is as small as possible and still contains all the control points. For example here is the convex hull for a set of eight points:
\begin{figure}[H]
    \centering
    \includegraphics[height=3cm]{img/bezier/convex_hull_8_points.png}
    \caption{A convex hull can be visualised as the area inside a rubber band fit around the points.}
\end{figure}

But, given the set $\{\bp_1,\ldots,\bp_n\}$why are all combinations $ \{p_1\bp_1 + \ldots + p_n\bp_n \; | \; p_1,\ldots,p_n\in[0,1] \; and \; \sum_{i=1}^n p_i = 1\}$ contained within the convex hull of the latter set? The lemma below proves why.
\begin{lemma}
If C is a convex set and $\bp_1,\ldots,\bp_n\in C$, then any convex combination (c.c.) $p_1\bp_1 + \ldots + p_n\bp_n$ (i.e. $p_i\geq0$ and $p_1+\ldots+p_n=1$) is also contained in C.
\end{lemma}
\begin{proof}
By induction.
For $n=1$ the lemma is trivial.
For $n=2$ ($p_1+p_2=1$) then the original set is simply the straight line between $p_1$ and $p_2$. The convex combination of $p_1$ and $p_2$ is also $p_1p_1 + (p_2-p_1)p_2$, which is the equation of the line segment between $p_1$ and $p_2$, therefore the c.c. is also within the original set.
Assume the statement is true for an integer $n-1, \; n \geq 3$, i.e. the c.c. of $\{p_1,\ldots,p_{n-1}\}$, which is any vector $\by$ such that:
\begin{align*}
\by = p_1\bp_1+\ldots+p_n\bp_{n-1}, \quad \forall \; p_i: \; p_i\geq 0, \; p_1+\ldots+p_{n-1}=1 \\
    \therefore \by = \frac{p_1}{p_1+\ldots+p_{n-1}}\bp_1 + \ldots + \frac{p_{n-1}}{p_1 + \ldots + p_{n-1}}\bp_{n-1}
\end{align*}
, is in C.
For the next integer $n$, we want to prove that $\bz=p_1\bp_1+\ldots+p_n\bp_n, \quad \forall \; p_i: \; p_i\geq 0, \; p_1+\ldots+p_n=1$ is also in C. However
\[
\bz = p_1\bp_1 + \ldots + p_{n-1}\bp_{n-1} + p_n\bp_n = (p_1+\ldots+p_{n-1})\by + p_n\bp_n
\]
Therefore $\bz$ lies in the segment between $\by$ and $\bp_n$. We know that both $\by$ and $\bp_n$ are in the convex set C and because C is convex all points along the latter segment (described by vector $\bz$) also belong in C. 
\end{proof}
Returning to the B\'ezier curve, these lemmas allows us to a establish a nice property about its shape. Recall that a B\'ezier curve is given by \eqref{eq:bezier_curve}:
\[
C(t) = (1-t)^3\bb_0 + 3(1-t)^2t\bb_1 + 3(1-t)t^3\bb_2 + t^3\bb_3
\]
It’s been proven that the weights $(1-t)^3,3(1-t)^2t,3(1-t)t^3,t^3$ are non-negative and sum to 1. Therefore we can establish the following nice property.
\begin{lemma}[B\'ezier curves and convex hull]
All points of the cubic Bezier curve 
\[
C(t) = (1-t)^3\bb_0 + 3(1-t)^2t\bb_1 + 3(1-t)t^3\bb_2 + t^3\bb_3
\]
lie within the convex hull defined by the four control points $\bb_0, \bb_1, \bb_2, \bb_3$.
\end{lemma}
This property is helpful as we know that the shape of the Bezier curve is spatially constrained in the polygon defined by $\bb_0, \bb_1, \bb_2, \bb_3$. Other curves, such as B-splines do not have that property, which makes them difficult to control or predict.

\begin{figure}[H]
    \centering
    \includegraphics[height=3.5cm]{img/bezier/convex_hull_cubic.png}
    \caption{A B\'ezier curve is always contained within of the convex hull of its control points.}%
    \label{fig:}
\end{figure}
The convex hull lemma holds for B\'ezier curves of any degree, however its generalisation will not be proven.



\subsubsection{Variation diminishing property}

Variation diminishing property limits how ``wiggly'' B\'ezier curves can be. Without any proof, it states that:
\begin{lemma}[variation diminishing of B\'ezier curves]
% ref wolfram
The number of  intersection points of any straight line with a Bezier curve is at most the number of intersection points of the same straight line with the control polygon of the curve.
\end{lemma}
In non technical words, it states that Bezier curves are smoother than the polygon formed by their control points. This property gives us another hint in advance regarding the shape of the Bezier curve to be drawn given some control points.

\begin{figure}[H]
    \centering
    % ref http://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node12.html?bcsi-ac-4d57fec82d0c41f9=271918E500000005p9MQ5tkLLOdTq7Ym5gWK7NO7uL3yAAAABQAAAL544gCAcAAAAQAAAFbLAQA=
    \includegraphics[height=4cm]{img/bezier/variation_diminishing.png}
    \caption{Left: The straight line crosses the B\'ezier curve up to 2 times and the polygon up to 2 times. Right: the straight line crosses the B\'ezier curve 3 times but cross the polygon 2 times.}%
    \label{fig:}
\end{figure}


\subsection{De Chasteljau'salgorithm to draw B\'ezier curves}
B\'ezier curves have some properties, but one needs to know how to draw them in practice. One could compute the Bernstein coefficients from \eqref{eq:bernstein_coeffs_general} for each $t$ but this gets computationally expensive, especially for large degrees $n$. De Chasteljau independently developed a recursive algorithm to compute each point of a Bezier curve without relying directly on \eqref{eq:bernstein_coeffs_general}. We will attempt to derive from scratch a De Chasteljau's method to draw cubic B\'ezier curves. 

% ref: notes06.pdf
The goal is to plot a cubic B\'ezier curve given 4 control points $\bb_0, \bb_1, \bb_2, \bb_3$. Suppose we want to plot a point $\bb_0^3(t)$ (this is not a control point, the weird superscript and subscript will become obvious later) in the curve for some fixed $t\in[0,1]$. Therefore $\bb_0^3(t)$ is written as:
\begin{align*}
    \bb_0^3(t) &= (1-t)^3\bb_0 + 3(1-t)^2t\bb_1 + 3(1-t)t^2\bb_2 + t^3\bb_3 \\
    &= (1-t)\underbrace{[(1-t)^2\bb_0 + 2(1-t)t\bb_1 + t^2\bb_2]}_{\bb_0^2} + t\underbrace{[(1-t)^2\bb_1 + 2(1-t)t\bb_2 + t^2\bb_3]}_{\bb_1^2}
    \tag{1}
\end{align*}
Eq. (1) expresses the point to draw $\bb_3^0(t)$ as a linear interpolation of two points $\bb_0^2(t)$ and $\bb_1^2(t)$. These points lie on two quadratic B\'ezier (coefficients sum to one and non-negative) curves. Therefore $\bb_3^0(t)$ is determined by two new control points $\bb_0^2(t)$ and $\bb_1^2(t)$. If we look at $\bb_0^2(t)$ and $\bb_1^2(t)$, then each point can be rewritten as:
\begin{align*}
    \bb_0^2(t) = & (1-t)^2\bb_0 + 2(1-t)t\bb_1 + t^2\bb_2 \\
    = & (1-t) [(1-t)\bb_0 + t\bb_1] + t [(1-t)\bb_1 + t\bb_2] \\
    \overeq{\bb_i = \bb_i^0} & (1-t) [\underbrace{(1-t)\bb_0^0 + t\bb_1^0}_{\bb_0^1}] + t [\underbrace{(1-t)\bb_1^0 + t\bb_2^0}_{\bb_1^1}]\ , \tag{2}\\
    \bb_1^2(t) &= (1-t) [\underbrace{(1-t)\bb_1^0 + t\bb_2^0}_{\bb_1^1}] + t [\underbrace{(1-t)\bb_2^0 + t\bb_3^0}_{\bb_2^1}] \tag{3}
\end{align*}
Eq. (2) and (3) state that each of $\bb_0^2(t)$ and $\bb_1^2(t)$ is determined as a linear interpolation of $\bb_0^1, \ \bb_1^1$ and $\bb_1^1, \ \bb_2^1$ respectively. Finally, moving on to $\bb_0^1, \bb_1^1$ and $\bb_2^1$, they are linear interpolations of the original control points. Renaming for consistency $\bb_i$ to $\bb_i^0$ respectively, where $i=0,1,2,3$, then $\bb_i^1$ is a linear interpolation of $\bb_i^0$ and $\bb_{i+1}^0$, $i=0,1,2$.

To summarise so far, Eq. (1), (2), (3) can be generalised as follows:
\begin{equation}
    \bb_i^j(t) = (1-t)\bb_i^{j-1}(t) + t\bb_{i+1}^{j-1}(t)\ , \quad i,j \leq 3
    \label{eq:de_chas_general}
\end{equation}
If \eqref{eq:de_chas_general} is unfolded, then it shows how $\bb_0^3$ can be computed in a pyramid-like recursive way.
\begin{figure}[H]
    \centering
    \includegraphics[height=4.5cm]{img/bezier/casteljau_terms_schema.png}
    \caption{Computing $\bb_0^3$ recursively from the control points. Arrow crossing denotes addition and each arrow denotes a multiplication.}%
    \label{fig:de_chasteljau_terms_schema}
\end{figure}

Therefore a pseudocode to implement De Chasteljau (with uniform sampling for $t$ from $0$ to $1$) is the following.

\begin{algorithm}[H]
\caption{De Chasteljau curve drawing with uniform sampling -- works with any number of control points, therefore curve of any degree.}
\label{alg:de_chasteljau}
\begin{algorithmic}[1]
    \Procedure {ComputePoint}{points, t} \Comment{Computes the topmost point of the DeChasteljau pyramid}
        \If {len(points) =  0}
            \State DrawPixel(points) \Comment{Only one point -- we're at the top}
        \Else
            \State higherLevelPoints $ \leftarrow \{\, \}$ 
            \For {i$ = 0,\ldots,\textup{len(points)-1}}$
                \State higherLevelPoint $\leftarrow (1-t)\textup{points[i]} + t\cdot \textup{points[i+1]}$
                \State higherLevelPoints.append(higherLevelPoint)
            \EndFor
            ComputePoint(higherLevelPoints)
        \EndIf
    \EndProcedure
    \State
    \Procedure{DeChasteljau} {$\bb_0,\ \bb_1,\ \bb_2,\ \bb_3,\ dt$} \Comment{$\bb_i$ are the control points, $dt$ the sampling width}
        \State $t\leftarrow 0$
        \While{$t\leq 1$}
            \State ComputePoint($\bb_0,\ \bb_1,\ \bb_2,\ \bb_3,\ t$)
            \State $t \leftarrow t + dt$
        \EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

Although uniform is relatively simple to implement, it was the drawback that if the portion of the curve being plotted is too flat (straight line), it's likely that we end up plotting redundant points. If the curve portion is too curvy, we may not plot enough points to capture its curvature. There are variations of the basic De Chasteljau's algorithm which subdivide the portion to draw based on the curvature, however they will not be discussed here.

To get better intuition, it's also helpful to understand how De Chasteljau's can be recreated geometrically. Again, beginning with the control points $\bb_0^0,\bb_1^0,\bb_2^0,\bb_3^0$ and for some $t\in[0,1]$, the steps are the following.
\begin{enumerate}
    \item For each line segment $\bb_0^0,\bb_1^0$, $\bb_1^0,\bb_2^0$, $\bb_2^0,\bb_3^0$, subdivide the segment starting from $\bb_{i+1}^0$ to $\bb_i^0$ at a ratio $t$ and $1-t$. Therefore each new point $\bb_i^1$ is located $t\times$ the length of the segment away from $\bb_{i}^0$.
    \item Now we have located $\bb_0^1,\bb_1^1, \bb_2^2$. Once again, $\bb_0^2$ is located $t\times$ the length of segment $\bb_0^1\bb_1^1$ away from $\bb_0^1$ and $\bb_1^2$ is located $t\times$ the length of segment $\bb_1^1\bb_2^1$ away from $\bb_1^1$.
    \item We have determined $\bb_0^2$ and $\bb_1^2$ so there's only the final point $\bb_0^3$ left to determine. Again, subdivide segment $\bb_0^2\bb_1^2$ and starting from $\bb_0^2$ move $t$ times its length away. That's where $\bb_0^3$ is located.
    \item Repeat for all necessary values of $t$.
\end{enumerate}

This is visualised by the figure below, where every colour denotes each step.

\begin{figure}[H]
    % creits https://tiborstanko.sk/teaching/geo-num-2016/tp1.html
    \centering
    \includegraphics[height=5cm]{img/bezier/casteljau_algo_bi.png}
    \caption{Geometrically obtaining $\bb_0^3$ starting from the control points $\bb_i^0$ for $t=0.5$.}%
\end{figure}

\begin{exmp}
    Given the control points $\bb_0=(-1,0), \bb_1=(0,1), \bb_2=(0,-1), \bb_3=(1,0)$, use De Chasteljau, to find the coordinates of $X(1/4)$.
\end{exmp}
\begin{soln}
We were given $t=1/4$.
\[
    \bb_0^1 = (1-t)\bb_0 + t\bb_1 = (-3/4, 1/4), \; \bb_1^1 = (1-t)\bb_1 + t\bb_2 = (0, 2/4), \; \bb_2^1 = (1-t)\bb_2 + t\bb_3 = (1/4,-3/4)
\]
\begin{align*}
    \bb_0^2 = (1-t)\bb_0^1 + t\bb_1^1 = 3/4 (-3/4, 1/4) + 1/4(0,2/4) = (-9/16, 5/16)\\
    \bb_1^2 = (1-t)\bb_1^1 + t\bb_2^1 = 3/4 (0, 2/4) + 1/4(1/4,-3/4) = (1/16, 3/16)
\end{align*}
\begin{align*}
    \bb_0^3 = (1-t)\bb_0^2 + t\bb_1^2 = 3/4 (-9/16, 5/16) + 1/4(1/16, 3/16) = (-26/64, 18/64)
\end{align*}
\end{soln}
De Chasteljau has been implemented in C in my \texttt{gfx-v4} repo at \url{https://github.com/0xLeo/gfx-v4}.


\clearpage
\section{Triangle fill algorithms}

There are various algorithms to draw a solid triangle. Here, we discuss three of them:
\begin{enumerate}
    \item Line sweep (row-by-row fill).
    \item Triangle interior test
    \item Bresenham-based fill.
\end{enumerate}

\subsection{Line sweep triangle fill}

Suppose we want to fill a triangle given points $P_1=(x_1,y_1)$, $P_2=(x_2,y_2)$, $P_3=(x_3,y_3)$, $y_1 \geq y_2 \geq y_3$. Line sweep fill fills the interior points of the triangle row by row relying on the fact that the slope of each line $P_1P_2$ and $P_2P_3$ is constant.

At each iteration, it keeps track of three variables -- the row number ($y$ coordinate), the leftmost ordinate (column) of the line to draw ($x_l$), and  the rightmost ordinate (column) of the line to draw ($x_r$). At each row sweep, we incrementally update $x_l$ and $x_r$. Then, we can fill all pixels from $x_l$ to $x_r$, forming a horizontal line (a.k.a. scanline). Finally, because the slope changes as we move from line $P_1P_2$ to $P_2P_3$, we first draw the top flat triangle $\Updelta(P_1P_2P_2')$ and then the $\Updelta(P_2'P_2P_3)$. 

\begin{figure}[H]
    \centering
    \subfloat[][\centering Triangle fill variables.]{\includegraphics[width=4.75cm]{img/triangle_fill_variables.png}}%
    \qquad
    \subfloat[][\centering Angles $a_1,a_2,a_3$ are utilised by the algorithm. highlighted.]{\includegraphics[width=4.75cm]{img/triangle_fill_variables_angles.png} }%
    \caption{Line sweep fill divides the original triangle in two flat ones. (a) The variables $y,x_l,x_r$ considered at each iteration. (b) The angles utilised by the algorithm to update $x_l$, $x_r$}%
    \label{fig:triangle_line_sweep_vars}%
\end{figure}

What's left to define is how $x_l$ and $x_r$ are updated at each iteration. Because $x$ is a function of $y$ (we iterated row-by-row), we increment the $y$ of each line by the \textit{inverse slope} (i.s.) of that line. The inverse slope has $x$ as the adjacent side and $y$ as the opposite, therefore $m_{inv} = \tfrac{\Delta x}{\Delta y}$. $x_l$ is always incremented by the inverse slope of line $\overline{P_1P_3}$ and $x_r$ is incremented by the i.s. of whatever line it belongs it; by $m_{inv,13}$ is if $y \leq y_2$, else by $m_{inv,23}$. The i.s. $m_{inv,13}$ of $\overline{P_1P_1}$ is the tangent of $a_3$ (Fig. \ref{fig:triangle_line_sweep_vars}):
\[
m_{inv,13} = \tan{a_3} = -\tan(\pi - a_3) = -\frac{x_1-x_3}{y_3-y_1} = \frac{x_3-x_1}{y_3-y_1}
\]
\begin{align*}
\therefore
    m_{inv,13} = \frac{x_3-x_1}{y_3-y_1}\\
    m_{inv,12} = \frac{x_2-x_1}{y_2-y_1}\\
    m_{inv,23} = \frac{x_3-x_2}{y_3-y_2}
\end{align*} 
The formulas would end up the same if $P_2$ was left of $P_3$. The final algorithm, which fills $\Updelta (P_1P_2P_2\prime)$ first, followed by $\Updelta ( P_2\prime P_2P_3)$ is listed below.

\begin{algorithm}[H]
\caption{Triangle fill by line sweep pseudocode.}
\begin{algorithmic}[1]
\Procedure{TriangleFillLineSweep} {$x_1,\ y_1,\ x_2,\ y_3,\ x_3,\ y_3$} \Comment{Assuming $y_1 < y_2 < y_3$}
    \State $m_{inv,13} \leftarrow \frac{x3-x_1}{y_3 - y_1}$
    \State $m_{inv,12} \leftarrow \frac{x2-x_1}{y_2 - y_1}$
    \State $m_{inv,23} \leftarrow \frac{x3-x_2}{y_3 - y_2}$
    \State $x_l \leftarrow x_1$
    \State $x_r \leftarrow x_1$
    \For{$y=y_1.\ .\ y_2$} \Comment{Flat top triangle}
        \For{$y=\textup{int}(x_l).\ .\ \textup{int}(x_r)$} \Comment{int denotes the casting from float to int}
            \State drawPixel($x,y$)
        \EndFor
        \State $x_l \leftarrow x_l + m_{inv,13}$
        \State $x_r \leftarrow x_r + m_{inv,12}$
    \EndFor
    \For{$y=y_2.\ .\ y_3$} \Comment{Flat bottom}
        \For{$y=\textup{int}(x_l).\ .\ \textup{int}(x_r)$}
            \State drawPixel($x,y$)
        \EndFor
        \State $x_l \leftarrow x_l +  m_{inv,13}$
        \State $x_r \leftarrow x_r +  m_{inv,23}$
    \EndFor
\EndProcedure
\end{algorithmic}
\label{alg:triangle_fill_line_sweep}
\end{algorithm}
This is super easy to implement and an implementation in C is found in my ``gfx-v4'' repository at \url{https://github.com/0xLeo/gfx-v4/blob/master/src/gfx/gfx.c#L395}.

% https://www.cs.princeton.edu/courses/archive/spring05/cos426/lectures/09-scan.pdf



\subsection{Triangle fill by interior test}


\subsubsection{Mathematical background}
Another method to fill the interior of a triangle is to find its bounding box, scan row-by-row all pixels in the box, and determine whether each pixel is in the interior of the triangle. The only tricky part about this algorithm is to derive an ``interior test''.

Before delving in the algorithm or in its maths, we need the definition of \emphasis{perpendicular } vector (a.k.a. \emphasis{perp}) in 2D.
\begin{definition}[perp vector]
Given a vector $\ba = (a_x, a_y)$, its \emphasis{perp vector} $\ba^{\bot}$ is defined as a vector with the same magnitude rotated by $90\degree$ ccw:
\begin{equation}
\ba^{\bot} = (-a_y, a_x)
\end{equation}
\end{definition}
\begin{figure}[H]
    % ref isbn 0-12-336155-9 p. 138
    \centering
    \includegraphics[height=2cm]{img/vec_perp.png}
    \caption{Vector $\ba$ and its ``perp'' ($\ba$) rotated by $90\degree$ ccw.}
\end{figure}

The perp vector comes in handy when we want to determine the relative orientation of two vectors, e.g. whether $\ba$ is cw or ccw from $\textbf{b}$. But first, it's imortant to clarify what is meant by cw and ccw. By saying that $\bb$ is cw of $\ba$, it is implied that to rotate $\bb$ by the \textit{inner} (smaller) angle until it's aligned with $\ba$, we move clockwise. Ccw rotation is defined in the same way. The figure below illustrates this.

\begin{figure}[H]
    \centering
    \subfloat[][\centering $\bb$ cw from $\ba$]{{\includegraphics[height=2.25cm]{img/b_cw_from_a.png} }}%
    \qquad
    \subfloat[][\centering $\bb$ ccw from $\ba$]{{\includegraphics[height=3cm]{img/b_ccw_from_a.png} }}%
    \caption{cw and ccw terminology}%
    \label{fig:cw_ccw_terms}%
\end{figure}

Back to the perp vector, how is it able to tell us the relative orientation between $\ba$ and $\bb$? Remember that $\bb^{\bot}$ is $\bb$ rotated by $90\degree$ ccw. It turns out that if $\bb$
 is ccw from $\ba$, then $\ba^{\bot}\bb = \norm{\ba}\norm{\bb}\cos(\theta) < 0$, since $\theta > 90\degree$ (Fig. \ref{fig:b_ccw_a_sign_pdot}).
 
\begin{figure}[H]
    \centering
    \subfloat[][\centering $\ba^{\bot}\bb <0$ when $b$ is ccw from $\ba$ and the angle between $\ba$, $\bb$ is obtuse.]{{\includegraphics[height=2.5cm]{img/a_perpdot_b_ccw_obtuse.png} }}%
    \qquad
    \subfloat[][\centering $\ba^{\bot}\bb <0$ when $b$ is ccw from $\ba$ and the angle between $\ba$, $\bb$ is acute.]{{\includegraphics[height=2.5cm]{img/a_perpdot_b_ccw_acute.png} }}%
    \caption{$\ba^{\bot}\bb <0$ when $\bb$ is ccw is $\ba$.}%
    \label{fig:b_ccw_a_sign_pdot}%
\end{figure}

Similarly, when $\bb$ is cw from $\ba$ then $\ba$, then $\ba^{\bot}\bb = \norm{\ba}\norm{\bb}\cos(\theta) > 0$, since $\theta < 90\degree$ (Fig. \ref{fig:b_ccw_a_sign_pdot}).

\begin{figure}[H]
    \centering
    \subfloat[][\centering $\ba^{\bot}\bb >0$ when $b$ is cw from $\ba$ and the angle between $\ba$, $\bb$ is obtuse.]{{\includegraphics[height=2cm]{img/a_perpdot_b_cw_obtuse.png} }}%
    \qquad
    \subfloat[][\centering $\ba^{\bot}\bb >0$ when $b$ is cw from $\ba$ and the angle between $\ba$, $\bb$ is acute.]{{\includegraphics[height=2cm]{img/a_perpdot_b_cw_acute.png} }}%
    \caption{$\ba^{\bot}\bb <0$ when $\bb$ is ccw is $\ba$.}%
    \label{fig:b_cw_a_sign_pdot}%
\end{figure}

Therefore the so-called ``perp dot product'' tells us the relative orientation between $\ba$ and $\bb$. To define it:

\begin{definition}[perp dot product]
The \emphasis{perp dot product} between $\ba$ and $\bb$ is defined as:
\begin{equation}
    pdot(\ba, \bb) = \ba ^{\bot} \bb  = 
    a_xb_y - a_yb_x
    \left|
    \begin{matrix}
    a_x & a_y \\
    b_x & b_y
    \end{matrix}
    \right |
\end{equation}
, where $\ba^{\bot}$ is $\ba$ rotated by $90\degree$, i.e. $\ba^{\bot} = \begin{bmatrix}
0 & -1 \\-1 & 0\end{bmatrix}\ba$.
\end{definition}
To summarise, it has the following properties:
\begin{corollary}[properties perp product]
\label{cor:prop_pdot_prod}
\begin{gather}
    \ba^{\bot} \bb > 0 \quad \textup{if} \quad \bb \quad \textup{ccw} \quad \textup{from} \quad \ba \label{eq:prop_pdot_ccw}\\
    \ba^{\bot} \bb < 0 \quad \textup{if} \quad \bb \quad \textup{cw} \quad \textup{from} \quad \ba \label{eq:prop_pdot_cw}
    \\
    \ba^{\bot} \bb = 0 \quad \textup{if} \quad \bb = \lambda \ba, \quad \lambda \in \setR
    \label{eq:prop_pdot_par}
\end{gather}
\end{corollary}


\subsubsection{Stating the interior test}

Using Cor. \ref{cor:prop_pdot_prod}, we can formulate whether a 2D point $P$ is inside or outside a triangle $\Updelta(P_1P_2P_3)$. We can use the perp dot product of vectors  $\overrightarrow{PP_1}$, $\overrightarrow{PP_2}$, and $\overrightarrow{PP_3}$ to deduce whether $P$ is inside or outside of the triangle, given that we know the relative orientation of points $P_1, P_2, P_3$, i.e. of vectors $\overrightarrow{OP_1}, \overrightarrow{OP_2},\overrightarrow{OP_3}$, where $O$ is the origin. To reiterate, We make two assumptions:
\begin{enumerate}
    \item $y_1 \leq y_2 \leq y_3$
    \item About the relative orientation of points $P_1, P_2, P_3$; they are either in cw or ccw.
\end{enumerate}

The figures below show the vectors $\overrightarrow{PP_1}$, $\overrightarrow{PP_2}$, and $\overrightarrow{PP_3}$ for the ccw and cw cases.

\begin{figure}[H]
    \centering
    \subfloat[][\centering Vectors connecting $P$ and $Q$ to the vertices  when $P_1, P_2, P_3$ are ccw.]{{\includegraphics[height=3.2cm]{img/triangle_int_ext_ccw.png} }}%
    \qquad \qquad
    \subfloat[][\centering Vectors connecting $P$ and $Q$ to the vertices  when $P_1, P_2, P_3$ are cw.]{{\includegraphics[height=3.2cm]{img/triangle_int_ext_cw.png} }}%
    \caption{For the interior test, we consider the vectors from a point to the vertices. The vectors for a typical interior point  $P$ and an exterior point $Q$ are drawn.}
    \label{fig:triangle_int_ext}
\end{figure}

From \eqref{eq:prop_pdot_cw}, \eqref{eq:prop_pdot_ccw} and Fig. \ref{fig:triangle_int_ext} we can see that in case $P_1,P_2,P_3$ are ccw, then for an interior point (e.g. $P$):
\begin{align*}
    \overrightarrow{PP_2} \quad \textup{ccw} \quad \textup{from} \quad \overrightarrow{PP_1} \Rightarrow \overrightarrow{PP_1}^{\bot}\overrightarrow{PP_2} > 0 \tag{1} \\
    \overrightarrow{PP_3} \quad \textup{ccw} \quad \textup{from} \quad \overrightarrow{PP_2} \Rightarrow \overrightarrow{PP_2}^{\bot}\overrightarrow{PP_3} > 0 \tag{2} \\
    \overrightarrow{PP_1} \quad \textup{ccw} \quad \textup{from} \quad \overrightarrow{PP_3} \Rightarrow \overrightarrow{PP_3}^{\bot}\overrightarrow{PP_1} > 0 \tag{3}
\end{align*}
Similarly, from the same figure and equations  for the cw case we obtain:
\begin{align*}
    \overrightarrow{PP_2} \quad \textup{cw} \quad \textup{from} \quad \overrightarrow{PP_1} \Rightarrow \overrightarrow{PP_1}^{\bot}\overrightarrow{PP_2} < 0 \tag{4} \\
    \overrightarrow{PP_3} \quad \textup{cw} \quad \textup{from} \quad \overrightarrow{PP_2} \Rightarrow \overrightarrow{PP_2}^{\bot}\overrightarrow{PP_3} < 0 \tag{5} \\
    \overrightarrow{PP_1} \quad \textup{cw} \quad \textup{from} \quad \overrightarrow{PP_3} \Rightarrow \overrightarrow{PP_3}^{\bot}\overrightarrow{PP_1} <  \tag{6}0
\end{align*}
, where $\overrightarrow{PP_i} = \overrightarrow{OP_i} - \overrightarrow{OP}$. To summarise, an interior point satisfies either Eq. (1) and Eq. (2) and Eq. (3) or Eq. (4) and Eq. (5) and Eq. (6). Otherwise, it's exterior. We can therefore state the interior test in pseudocode as follows.
\begin{algorithm}[H]
\caption{Testing whether a point $P(x,y)$ lies in the interior of a triangle $\Updelta(P_1P_2P_3)$.}
\begin{algorithmic}[1]
\Procedure{PerdDotProd}{$x_1,y_1,x_2,y_2$}
\State \textbf{return} $x_1y_2 - y_1x2$
\State
\EndProcedure
\Procedure{IsInterior} {$x_1,y_1,x_2,y_2,x_3,y_3,x,y$}
\State $PP1_x \leftarrow x - x_1$ \Comment{vector from $P(x,y)$ to verices $P_i(x_i,y_i)$}
\State $PP1_y \leftarrow y - y_1$
\State $PP2_x \leftarrow x - x_2$
\State $PP2_y \leftarrow y - y_2$
\State $PP3_x \leftarrow x - x_3$
\State $PP3_y \leftarrow y - y_3$
\State cw $\leftarrow$ PerdDotProd$(PP1_x,PP1_y,PP2_x,PP2_y) < 0$ AND

\quad PerdDotProd$(PP2_x,PP2_y,PP3_x,PP3_y) < 0$ AND

\quad PerdDotProd$(PP3_x,PP3_y,PP1_x,PP1_y) < 0$
\State ccw$\leftarrow$ PerdDotProd$(PP1_x,PP1_y,PP2_x,PP2_y) > 0$ AND 

\quad PerdDotProd$(PP2_x,PP2_y,PP3_x,PP3_y) > 0$ AND

\quad PerdDotProd$(PP3_x,PP3_y,PP1_x,PP1_y) > 0$
\State \textbf{return} cw OR ccw \Comment{cw and ccw are boolean type}
\EndProcedure
\end{algorithmic}
\label{alg:triangle_fill_int_test}
\end{algorithm}

\subsubsection{The algorithm}

As usual, the aim of the algorithm is to fill a triangle given 3 points $P_1, P_2, P_3$, assuming $y_1\leq y_2 \leq y_3$. We can then iterate over every pixel of the bounding box of the triangle (see Fig. \ref{fig:triangle_line_sweep_vars}) and apply the interior test (Alg. \ref{alg:triangle_fill_int_test}) to each. Below is the basic pseudocode, without any cache misses/ hits considered.

\begin{algorithm}[H]
\caption{Triangle fill by interior test (see Alg. \ref{alg:triangle_fill_int_test} for interior test).}
\begin{algorithmic}[1]
\Procedure{TriangleFillInteriorTest} {$x_1,y_1,x_2,y_2,x_3,y_3$} \Comment{Assuming $y_1\leq y_2 \leq y_3$}
\State xmin $\leftarrow \min(x_1,x_2,x_3)$
\State xmax $\leftarrow \max(x_1,x_2,x_3)$
\For{x$\leftarrow$ xmin $. \ . \ $ xmax}
\For{y$\leftarrow y_1. \ . \ y3$}
\If{IsInterior(x,y)} putPixel(x,y)
\EndIf
\EndFor
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
This algorithm completely avoids floating point operations, unlike Alg. \ref{alg:triangle_fill_line_sweep} (triangle fill by line sweep). In my ``gfx-v4'' repo, it is implemented in \url{https://github.com/0xLeo/gfx-v4/blob/master/src/gfx/gfx.c#L444}.
% https://blackpawn.com/texts/pointinpoly/#:~:text=Same%20Side%20Technique,triangle%2C%20otherwise%20it%20is%20not.
% http://www.sunshine2k.de/coding/java/PointInTriangle/PointInTriangle.html#perpdotproduct
% https://courses.cs.washington.edu/courses/cse457/06au/lectures/triangle_intersection.pdf
% https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle

% implementation tips:
% https://stackoverflow.com/a/30982985



\clearpage
\section{Circle rasterisation (midpoint algorithm)}

\subsection{Derivation of the algorithm}
One way to draw a circle centred at $(0,0)$ is by plotting the two $y$'s given by the circle equation for each $x$.  
\begin{align*}
x^2+y^2=r^2 \Rightarrow \\
y = \pm \sqrt{r^2 - x^2}
\end{align*}
However, this method has two drawbacks; the square root is very expensive and the line is not guaranteed to be continuous, especially when the slope is high.

The goal is to derive an algorithm that plots a continuous circle using cheap operations. We can exploit the 8--way symmetry of a circle about its centre to derive the algorithm for one octant and then derive the rest, as illustrated in Fig. \ref{fig:all_octants_x_y}. 

For the sake of convention, we will start with octant 2, i.e. starting from $x=0,\ y=r$ and incrementing $x$ until $y=x$, therefore for the slope $m$: $0 \leq m \leq 1$. Because we work in octant 2 (going clockwise), assuming we have just plotted pixel $(x_p,y_p)$, we can either move to $E(x_p+1, y_p)$ or $SE(x_p+1, y_p-1)$ (Fig. \ref{fig:bres_algo_next_pixel}). Which of the two to select though? The idea is that if the circle curve passes above the midpoint $M(x_p+1, y_p-\tfrac{1}{2})$ of the next two choices, then we select $E(x_p+1, y_p)$. Otherwise, we select $SE(x_p+1, y_p-1)$.

\begin{figure}[H]
    \centering
    \includegraphics[height=3.25cm]{img/bres_algo_next_pixel.png}
    \caption{The two possible choices for the next pixel when drawing a circle at octant 2; E and SE. For the above curve, we select E and SE as the next two pixels (striped).}
    \label{fig:bres_algo_next_pixel}
\end{figure}

We need a decision variable to determine which pixel to visit next (E or SE). The midpoint $M$ between S and SE is at distance $(x_p+1)^2 + (y_p - \tfrac{1}{2})^2$ from the origin. As shown in Fig. \ref{fig:bres_algo_next_pixel}:
\begin{itemize}
    \item If $r^2 \geq (x_p+1)^2 + (y_p - \tfrac{1}{2})^2$, then we choose to visit the E pixel as it's closer to the line.
    \item Otherwise SE is closer and we visit this one.
\end{itemize}
Therefore we define the decision variable w.r.t. the midpoint $M(x_p+1, y_p-\tfrac{1}{2})$ as:
\begin{align*}
    D &= F(M) = F\Bigg(x_p+1, y_p-\frac{1}{2}\Bigg)\\
    &= (x_p+1)^2 + (y_p-\frac{1}{2})^2 - r^2
\end{align*}
And we decide:
\begin{itemize}
    \item If $D\geq 0$, the next pixel is SE.
    \item If $D<0$, the next pixel is E.
\end{itemize}
It's important to note that at each iteration we compute the current $D$ given the previous. Therefore we need to define how we accumulate it in case E or SE was chosen next.
\begin{itemize}
    \item In case $E(x_p+1, y_p-\tfrac{1}{2})$ was chosen, then the new midpoint (at $x_p+1+1$) is $M(x_p+2, y_p-\frac{1}{2})$. Then it can be proven (App. \ref{app:decision_var_update}) that the new value of the decision variable is:
    \begin{equation}
    D_{E} = D + (2x_p + 3)
    \label{eq:de}
    \end{equation}
    Hence, $D$ is incremented by $2x_p + 3$.
    \item In case $SE(x_p+1, y_p-1-\tfrac{1}{2})$ was chosen, then the new midpoint is also $M(x_p+2, y_p-\frac{1}{2})$ -- same as before. Then it can be proven (App. \ref{app:decision_var_update}) that the decision variable $D$ is incremented by $2x_p-2y_p+5$:
    \begin{equation}
        D_{SE} = D + (2x_p-2y_p+5)    
        \label{eq:d_se}
    \end{equation}
    
\end{itemize}
All that's left to define is how to initialise $D$. Because we start at $(0, r)$ going clockwise, the first midpoint is at $M(1, r - \tfrac{1}{2})$. Therefore the initial decision variable is:
\begin{align*}
    D_0 &= F(1, r-\frac{1}{2}) \\
    &= 1 + (r-\frac{1}{2})^2  - r^2 \\
    &= 1+ r^2 - r + \frac{1}{4} - r^2\\
    &= \frac{5}{4} - r  
\end{align*}
To avoid dealing with floating points ($\tfrac{5}{4}$), notice that on each iteration we compare $D$ to 0. $D$ also gets updated with an integer quantity -- either $2x_p+3$ or $2x_p-2y_p+5$. Therefore $D+\tfrac{1}{4}$ is positive only when $D$ is positive; it is safe to drop the $\tfrac{1}{4}$. Hence, we can set $D_0$ to $1-r$ instead.
\begin{equation}
    D_0 = 1-r
    \label{eq:d_0}
\end{equation}
Using the update rules in \eqref{eq:de}, \eqref{eq:d_se}, \eqref{eq:d_0}, we can draw a circular arc on the 2nd octant and mirror it on the rest to draw a full circle.

% https://www.cs.bgu.ac.il/~graph161/wiki.files/09c-Rasterization.pdf
% https://www.cs.bgu.ac.il/~graph161/wiki.files/09c-Rasterization.pdf
% https://en.wikipedia.org/wiki/Midpoint_circle_algorithm
% http://clux.x-pec.com/files/mathstuff/4thyear/CS324%20Computer%20Graphics/bres2.pdf
% https://weber.itn.liu.se/~stegu/circle/circlealgorithm.pdf
% https://stackoverflow.com/questions/33526137/where-am-i-going-wrong-in-bresenham-circle-drawing-algorithm
% https://www.ques10.com/p/22016/explain-mid-point-circle-generation-algorithm-in-d/
% file:///tmp/4221.pdf



\subsection{Pseudocode and implementation of the algorithm}

% ref https://www.ques10.com/p/22016/explain-mid-point-circle-generation-algorithm-in-d/
\begin{algorithm}[H]
\caption{Midpoint algorithm for circle drawing at a point $(x_0,y_0)$ with radius $r$.}
\begin{algorithmic}[1]
\Procedure{MidpointAlgorithm} {$x_0,y_0,r$}
\State $x \leftarrow 0$
\State $y \leftarrow r$
\State $D \leftarrow 1 - r$ \Comment{Decision variable}
\Do
    \State putPixel($x + x_0,\ y + y_0$)    \Comment{Octant 2; draw all octants to fill the circle}
    \State putPixel($y + x_0,\ x + y_0$)    \Comment{Octant 1}
    \State putPixel($-x + x_0,\ y + y_0$)    \Comment{Octant 3}
    \State putPixel($-y + x_0,\ x + y_0$)    \Comment{Octant 4}
    \State putPixel($-y + x_0,\ -x + y_0$)    \Comment{Octant 5}
    \State putPixel($-x + x_0,\ -x + y_0$)    \Comment{Octant 6}
    \State putPixel($x + x_0,\ -y + y_0$)    \Comment{Octant 7}
    \State putPixel($y + x_0,\ -x + y_0$)    \Comment{Octant 8}
    \If{$D<0$}
        \State $D\leftarrow D + 2x + 3$
    \Else
        \State $y\leftarrow y - 1$
        \State $D \leftarrow D + 2x - 2y + 5$
    \EndIf  
    \State $x \leftarrow x + 1$
\doWhile{$x < y$} % <--- use \doWhile for the "while" at the end
\EndProcedure
\end{algorithmic}
\end{algorithm}
An implementation in C is found in my ``gfx-v4'' repo at \url{https://github.com/0xLeo/gfx-v4/blob/master/src/gfx/gfx.c#L355}.

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% References
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\printbibliography



%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% Appendices
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\appendix

\section{Appendices}

% ------------------------ New appendix ------------------------ %

\subsection{Bresenham's straight line drawing algorithm -- pseudocode}
\label{app:bresenham_full_pseudo}

\begin{algorithm}[H]
\caption{Bresenham's full line drawing.}
\label{alg:bres_pt2}
\begin{algorithmic}[1]
	\Procedure{Find-Octant} {$x_1,y_1,x_2,y_2$} \Comment{See Fig. \ref{fig:octants}}
	\State $m \leftarrow \frac{y_2-y_1}{x_2-x_1}$
	\If {$x_1 \leq x_2$ and $0\leq m \leq 1$}
		\State \textbf{return} 0 \Comment{1st}
	\ElsIf {$y_1 \leq y_2$ and $ m > 1$}
		\State \textbf{return} 1 \Comment{etc.}
	\ElsIf {$y_1 \leq y_2$ and $ m < -1 $}
		\State \textbf{return} 2
	\ElsIf {$x_2 \leq x_1$ and $0 \geq m \geq -1$}
		\State \textbf{return} 3
	\ElsIf {$x_2 \leq  x_1$ and $0 < m \leq 1$}
		\State \textbf{return} 4
	\ElsIf {$y_2 \leq  y_1$ and $ m > 1$}
		\State \textbf{return} 5
	\ElsIf {$y_2 \leq y_1$ and $ m < -1$}
		\State \textbf{return} 6
	\ElsIf {$x_1 \leq x_2$ and $-1 \leq m \leq 0$}
		\State \textbf{return} 7
	\Else \Comment{$x_1 = x_2$, vertical line}
		\State \textbf{return} 8
	\EndIf
\EndProcedure
\State
\Procedure{Bresenham} {$x_1,\; y_1,\; x_2,\; y_2$} 
	\State $\Delta x \leftarrow x_2 - x_1$
	\State $\Delta y \leftarrow y_2 - y_1$
	\State $\epsilon \leftarrow 0$
	\State $oct \leftarrow$ Find-Octant($x1,y1,x2,y2$)
	\If {$oct = 0$} \Comment{0 to 45 degrees with $x$ axis}
		\State $y \leftarrow y_1$
		\For {$x=x1..x2$}
			\State Draw-Pixel($x,y$)
			\State $\epsilon \leftarrow \epsilon + \Delta y$
			\If {$2\epsilon \geq \Delta x$}
				\State $\epsilon \leftarrow \epsilon - \Delta x$
				\State $y \leftarrow y + 1$
			\EndIf
		\EndFor
	\ElsIf {$oct = 1$} \Comment{45 to 90}
		\State $x \leftarrow x_1$
		\For {$y = y_1..y_2$}
			\State Draw-Pixel($x,y$)
			\State $\epsilon \leftarrow \epsilon + \Delta x$
			\If {$2\epsilon \geq \Delta y$}
				\State $\epsilon \leftarrow - \Delta y$
				\State $x \leftarrow x + 1$
			\EndIf
		\EndFor
	\ElsIf {$oct = 2$} \Comment{90 to 135}
		\State $x \leftarrow x_1$
		\For {$y=y_1..y_2$}
			\State Draw-Pixel($x,y$)
			\State $\epsilon \leftarrow \epsilon - \Delta x$
			\If { $2\epsilon \geq \Delta$}
				\State $\epsilon \leftarrow \epsilon - \Delta y$
				\State $x \leftarrow x - 1$
			\EndIf
		\EndFor
	\ElsIf {$oct = 3$}  \Comment{135 to 180}
		\State $y \leftarrow y_1$
		\For {$x=x_1..x_2$}
			\State Draw-Pixel($x,y$)

		\EndFor
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\caption{Bresenham's full line drawing -- cont'ed}
\label{alg:bres_pt2}
\begin{algorithmic}[1]
	\Indent
	\State $\epsilon \leftarrow \epsilon + \Delta x$
	\If {$2\epsilon \geq - \Delta x$}
		\State $\epsilon \leftarrow \epsilon + \Delta x$
		\State $y \leftarrow y + 1$
	\ElsIf {$oct = 4$}  \Comment{180 to 215}
		\State $y\leftarrow y_1$
		\For { $x=x_1..x_2$}
			\State Draw-Pixel($x,y$)
			\State $\epsilon \leftarrow \epsilon - \Delta y$
			\If {$2\epsilon \geq -\Delta x$}
				\State $\epsilon \leftarrow \epsilon + \Delta x$
				\State $y \leftarrow y - 1$
			\EndIf
		\EndFor
	\ElsIf {$oct = 5$} \Comment{215 to 270}
		\State $x\leftarrow x_1$
		\For {$y=y_1..y_2$}
			\State Draw-Pixel($x,y$)
			\State $\epsilon \leftarrow \epsilon - \Delta x$
			\If {$2\epsilon \geq - \Delta y$}
				\State $\epsilon \leftarrow \epsilon - \Delta y$
				\State $x \leftarrow x - 1$
			\EndIf
		\EndFor
	\ElsIf {$oct = 6$} \Comment{270 to 315}
		\State $x = x_1$
		\For {$y=y_1..y_2$}
			\State Draw-Pixel($x,y$)
			\State $\epsilon \leftarrow \epsilon + \Delta x$
			\If {$2\epsilon \geq -\Delta y$}
				\State $\epsilon \leftarrow \epsilon + \Delta y$
				\State $x\leftarrow x+1$
			\EndIf
		\EndFor
	\ElsIf {$oct = 7$} \Comment{315 to 360}
		\State $x\leftarrow x_1$
		\For {$y=y_1..y_2$}
			\State Draw-Pixel($x,y$)
			\State $\epsilon \leftarrow \epsilon + \Delta x$
			\If {$2\epsilon \geq -\Delta y$}
				\State $\epsilon \leftarrow \epsilon + \Delta y$
				\State $x\leftarrow x+ 1$
			\EndIf
		\EndFor
	\ElsIf {$oct = 8$} \Comment{Vertical line}
	\State \Comment{Draw a vertical at line at $x_1$ between $y1,\; y_2$}
	\EndIf
	\EndIndent
\end{algorithmic}
\end{algorithm}


\newpage
\subsection{Bresenham's line drawing source code in C}
\label{app:bresenham_full_src}

From \url{https://github.com/0xLeo/gfx-v4}.
\lstinputlisting[language=C,caption={Bresenham's code (\detokenize{src/bresenham.c)}.}, label=src:mylabel]{src/bresenham.c}


%---------------------------------------- new appendix ----------------------------------------
\newpage
\subsection{Parametric form of straight line}
\label{app:param_straight_line}

\begin{lemma}
Given two points $P_0$, $P_1$ and a parameter $t\in\setR$, a straight line can be parametrised as:
\begin{equation}
P(t) = (1-t)P_0 + tP_1
\end{equation}
, where $P = (x,y),\; P_0=(x_0,y_0), \; P_1=(x_1,y_1)$.
\end{lemma}
Unwrapping this equation in each dimension, the points $(x(t), y(t))$ of line $P_0P_1$ are given by 
\begin{align*}
x(t) = (1-t)x_0 + tx_1\\
y(t) = (1-t)y_0 + ty_1
\end{align*}
If we restrict $t\in[0,1]$, then we obtain the line segment bar $P_0P_1$, i.e. as $t$ changes from 0 to 1 we move between $P_0$ and $P_1$. For $t=0$, $P$ coincides with $P_0$, and for $t=1$ with $P_1$.
\begin{proof}
    As the figure below shows, any point between $P_0$ and $P_1$ can be reached from $P_0$ by adding $t(\bp_1-\bp_0)$ to it, where $t$ is a normalised scalar indicating where p falls along line $\bp_0\bp_1$ ($t=0$ at $\bp_0$, $t=1$ at $\bp_1$). Therefore:
\[
    \bp=\bp_0+t(\bp_1-\bp_0) = (1-t)\bp_0 + t\bp_1
\]
\begin{figure}[H]
    \centering
    \includegraphics[height=3cm]{img/bezier/param_straight_line.png}
    \caption{How a point $\bp$ along a straight segment defined by $\bp_1,\bp_2$ can be parametrised.}%
\end{figure}
\end{proof}

%---------------------------------------- new appendix ----------------------------------------
\newpage
\subsection{Midpoint algorithm -- decision variable update}
\label{app:decision_var_update}
In case $E(x_p+2, y_p-\frac{1}{2})$ was chosen as the next point, then the new decision variable variable is:
\begin{align*}
    D_E &= F(x_p + 2, y_p - \frac{1}{2}) \\
        &= (x_p+2)^2 + (y_p - \frac{1}{2})^2 - r^2 \\
        &= (x_p^2+4x_p+2) + (y_p-\frac{1}{2})^2 - r^2 \\
        &= (x_p +2x_p + 1) + (2x_p + 3) + (y_p-\frac{1}{2})^2 - r^2 \\
        &= (x_p+1)^2 + (y_p-\frac{1}{2})^2 -r^2 + (2x_p + 3) \\
        &= D + (2x_p+3)
\end{align*}
In case $SE(x_p+2, y_p-1-\frac{1}{2})$ was chosen as the next point, then the new decision variable variable is:
\begin{align*}
    D_{SE} &= F(x_p+2, y_p -\frac{3}{2}) \\
    &= (x_p+2)^2 + (y_p-\frac{3}{2})^2 \\
    &= (x_p^2 + 2x_p + 1) + (2x_p+3) + (y_p^2 -y_p + \frac{1}{4}) + (-2y_p+\frac{8}{4}) - r^2 \\
    &= (x_p+1)^2 + (y_p - \frac{1}{2})^2 - r^2 + (2x_p+3) + (-2y_p + 2) \\
    &= D + (2x_p -2y_p + 5)
\end{align*}

\end{document}
